BitcoinMiner Pseudocode Format Specification:
Code source: https://github.com/Mr-Ye-Cao/original-bitcoin/blob/master/src/main.cpp

SECTION # (LINE # - LINE #){
Verb Noun
elaboration / details
}

SECTION 1 (L 2195 - L 2200){
Print debug info

Set Thread Priority
    Set mining thread priority lowest

Create EC_KEY_generate_key and extraNonce
    Initate CKey object 
    Call EC_KEY_generate_key (construct by calling elliptive curve function library)
    Initiate extraNonce to be 0
}


SECTION 2 (L 2202 - 2467){

Check global variable fGenerateBitcoins
    fGenerateBitcoins's boolean value determines if mining computation will happen
        if fGenerateBitcoins is false 
            the rest of this SECTION 2 won't happen
            the code will jump to the end of line 2469 and return fucntion BitcoinMiner
    fGenerateBitcoins is controled in 
        src/ui.cpp L 824 fGenerateBitcoins = event.IsChecked();
                   L 3024 set to true
                   ...


Make the current thread sleep for 50 seconds

Shut down the ThreadBitcoinMiner if fShutdown is true
    ThreadBitcoinMiner is vfThreadRunning's 3rd thread
        vfThreadRunning is a 4 slots array that marks the on/off of each thread
            vfThreadRunning[0]: ThreadSocketHandler
            vfThreadRunning[1]: ThreadOpenConnections
            vfThreadRunning[2]: ThreadMessageHandler
            vfThreadRunning[3]: ThreadBitcoinMiner
    By calling net.cpp L 1061 CheckForShutdown
        fShutdown's boolean value determines if the thread will be shut down
            if fShutdown is true then end ThreadBitcoinMiner thread
        fShutdown is only true 
            if net.cpp L 1039 in stopNode() was executed
            StopNode() is called in ui.cpp L 351
                Happens when UI is shut down


Check if the vNode is empty
    vNode is a vector of Node where each node is a network p2p connection
    if empty 
        make current thread sleep for 1000 seconds (16.66mins)
        Execute L37 to L50 in this document

Make a copy of the current nTransactionsUpdated

Make a copy of the pindexBest
    pindexBest is a pointer to the index(datastructure CBlockIndex) of the node in the longest chain

Determine the number of bits for the new block and store as variable nBits
    By calling the function GetNextWorkRequired(pindexPrev) main.cpp L 685
        Initialize variable nTargetTimespan equal to 2 weeks
        Initialize variable nTargetSpacing which is equal to 10 minutes
        Initialize variable nInterval which is equal to the number of intervals based on the spacing being 10 minutes
        Check if pindexLast i.e. pointer to previous node of longest block is null
            if so the number of bits is calculated in bignum.h L 269
                bnProofOfWorkLimit is the upperbound of proof of work difficulty
                bnProofOfWorkLimit's format is transformed using BN_bn2mpi(a, to)
                    BN_bn2mpi(a, to) stores the representation of a at to, where *to must be large enough to hold the result. The size can be determined by calling BN_bn2mpi(a, NULL).
        Check if the previous block's height is evenly divisible by nInterval
            if so use the previous POW difficulty
        Make a copy of pindexFirst as pindexFirst
        Go back to the block representing the beginning of two weeks
            On average every ten minutes creates a new block, so in two weeks there are nInterval number of blocks.
            This estimate 10 mins per block is only rough estimate. So the limit adjustment happens next
        Get the actual time difference between pindexLast(last block) and pindexFirst(first block) and store in variable nActualTimespan
        Adjust nActualTimespan
            If nActualTimespan is less than a quarter of nTargetTimespan
                Make nActualTimespan exactly a quarter of nTargetTimespan
            If nActualTimespan is greater than a 4 times of nTargetTimespan
                Make nActualTimespan exactly 4 times of nTargetTimespan
        Get the number of bits for last block (pindexLast) store in variable bnNew
        Adjust bnNew based on the nActualTimespan and nTargetTimespan
        If bnNew, i.e. the bits of difficulty is more than the POW limit
            Make bnNew equal to POW limit

Create variable txNew of type CTransaction (class defined in main.h L357)
Resize the input vector field of txNew to 1
Set the input vector's first element's prevout field to be null
    prevout field points to where coins were created, i.e. previous transaction
Set the input vector's first element's scriptSig to be concatenation of nBits and bnExtraNonce+1
Resize the output vector field of txNew to 1
Set the output vector's first element's scriptPubKey to be concatenation of public key created in L15 and op code OP_CHECKSIG

Create a pointer named pblock of type CBlock
    The pointer pblock points to the memory address: (new CBlock())
    Class CBlock is defined in main.h L 812

Push the coinbase transaction created in L 91 into pblock's vtx field
    The pblock's vtx field is a vector of transactions of the block

Initialize variable nFees as 0 to store the amount of reward to the miner
    The variable's value will be set later

Create variable txdb of CTxDB (defined in db.h) which will be used to read transactions from it
    txdb is a database of transactions
    Here txdb is in read mode: txdb("r")

Create variable mapTestPool of type map<uint256, CTxIndex>
    mapTestPool is used as a pool of collected transactions

Create variable vfAlreadyAdded of size mapTransactions 
    vfAlreadyAdded is to denote which transaction from mapTransactions has been added
    mapTransactions is a global state that updated in AcceptTransaction() in main.cpp L 468

Create boolean flag fFoundSomething as true

Initialize variable nBlockSize as 0 that records the size of current block

Check if fFoundSomething is true and nBlockSize is less than MAX_SIZE
    MAX_SIZE is used to constain the size of block and therefore
    the number of transactions it contains.

Tentatively set fFoundSomething to false

Initialize variable n which is used to mark if nth transaction has been added by checking vfAlreadyAdded

Iterate over the mapTransactions (type map<uint256, CTransaction>) while increment n

Check if nth transaction has been added by checking vfAlreadyAdded
    if so, go to next iteration

Retrieve CTransaction of the current transaction and store by reference as tx

Check if one of following conditions is true, don't add transaction tx
    1) tx is coinbase transaction
        Because coinbase transaction is already in the block, txNew in L 103
    2) tx is not finalized
        IsFinal() is defined in main.h L 405
        Don't fully understand what IsFinal() is trying to do

Initialize variable nMinFee Calculated in GetMinFee() (defined in main.h L 511)
    if tx's serialized size < 10000 and block's vector of transaction size less than 100
        cost is 0
    otherwise
        cost = (1 + (int64)tx's serialized size / 1000) * CENT

Create a temporary variable mapTestPoolTmp by making a copy of mapTestPool

Connect the info tx through ConnectInputs
    if failed, go to next iteration
    ConnectInputs is defined in main.cpp L 773
        check if transaction is coinbase
        if not coinbase
        ... worth going further
        Update nFees, i.e. reward to the miner at L 855

Swap the pointer of mapTestPool and mapTestPoolTmp
    Pointer mapTestPool now points to memory address containing the new transaction tx
    Therefore mapTestPool successfully collects the new transaction

Push new transaction tx into pblock's vtx field

Update the block size nBlockSize accouting the size of newly added transaction tx

Mark the nth transaction has been added by updating vfAlreadyAdded[n]

Update flag fFoundSomething to be true

Write down nBits into the field of pblock->nBits

Write down transaction vector's first transaction's first output's nValue to be nFees




}